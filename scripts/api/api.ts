/* tslint:disable */
/* eslint-disable */
/**
 * Cakemix Server API
 * Definition of Cakemix Server API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@wonder-wonder.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { API_BASE_URL, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Response model for /auth/lock
 * @export
 * @interface AuthLockResModel
 */
export interface AuthLockResModel {
    /**
     * 
     * @type {boolean}
     * @memberof AuthLockResModel
     */
    status: boolean;
}
/**
 * 
 * @export
 * @interface AuthLogLoginModel
 */
export interface AuthLogLoginModel {
    /**
     * 
     * @type {string}
     * @memberof AuthLogLoginModel
     */
    sessionid?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogLoginModel
     */
    ipaddr?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogLoginModel
     */
    devinfo?: string;
}
/**
 * 
 * @export
 * @interface AuthLogModel
 */
export interface AuthLogModel {
    /**
     * 
     * @type {ProfileModel}
     * @memberof AuthLogModel
     */
    user: ProfileModel;
    /**
     * 
     * @type {number}
     * @memberof AuthLogModel
     */
    date: number;
    /**
     * 
     * @type {string}
     * @memberof AuthLogModel
     */
    type: string;
    /**
     * 
     * @type {AuthLogLoginModel | AuthLogPassResetModel | AuthLogPassChangeModel}
     * @memberof AuthLogModel
     */
    data?: AuthLogLoginModel | AuthLogPassResetModel | AuthLogPassChangeModel;
}
/**
 * 
 * @export
 * @interface AuthLogPassChangeModel
 */
export interface AuthLogPassChangeModel {
    /**
     * 
     * @type {string}
     * @memberof AuthLogPassChangeModel
     */
    sessionid?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogPassChangeModel
     */
    ipaddr?: string;
}
/**
 * 
 * @export
 * @interface AuthLogPassResetModel
 */
export interface AuthLogPassResetModel {
    /**
     * 
     * @type {string}
     * @memberof AuthLogPassResetModel
     */
    ipaddr?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLogPassResetModel
     */
    devinfo?: string;
}
/**
 * 
 * @export
 * @interface AuthLogResModel
 */
export interface AuthLogResModel {
    /**
     * 
     * @type {number}
     * @memberof AuthLogResModel
     */
    offset: number;
    /**
     * 
     * @type {number}
     * @memberof AuthLogResModel
     */
    len: number;
    /**
     * 
     * @type {Array<AuthLogModel>}
     * @memberof AuthLogResModel
     */
    logs: Array<AuthLogModel>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthLogResModel
     */
    has_next: boolean;
}
/**
 * Request model for /auth/login
 * @export
 * @interface AuthLoginReqModel
 */
export interface AuthLoginReqModel {
    /**
     * Email address or username
     * @type {string}
     * @memberof AuthLoginReqModel
     */
    id: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthLoginReqModel
     */
    pass: string;
}
/**
 * Response model for /auth/login
 * @export
 * @interface AuthLoginResModel
 */
export interface AuthLoginResModel {
    /**
     * JWT token
     * @type {string}
     * @memberof AuthLoginResModel
     */
    jwt: string;
}
/**
 * Request model for /auth/pass/change and /auth/pass/reset/verify/{token}
 * @export
 * @interface AuthPassChangeReqModel
 */
export interface AuthPassChangeReqModel {
    /**
     * Old password
     * @type {string}
     * @memberof AuthPassChangeReqModel
     */
    oldpass?: string;
    /**
     * New password
     * @type {string}
     * @memberof AuthPassChangeReqModel
     */
    newpass: string;
}
/**
 * Request model for /auth/pass/reset
 * @export
 * @interface AuthPassResetReqModel
 */
export interface AuthPassResetReqModel {
    /**
     * Email for user to reset password
     * @type {string}
     * @memberof AuthPassResetReqModel
     */
    email: string;
}
/**
 * Request model for /auth/regist/new/token
 * @export
 * @interface AuthRegistNewTokenResModel
 */
export interface AuthRegistNewTokenResModel {
    /**
     * Token for registering
     * @type {string}
     * @memberof AuthRegistNewTokenResModel
     */
    token: string;
}
/**
 * Request model for /auth/regist
 * @export
 * @interface AuthRegistReqModel
 */
export interface AuthRegistReqModel {
    /**
     * Email address
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    email: string;
    /**
     * Username
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    username: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    password: string;
}
/**
 * Session info
 * @export
 * @interface AuthSessionModel
 */
export interface AuthSessionModel {
    /**
     * 
     * @type {string}
     * @memberof AuthSessionModel
     */
    sessionid?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthSessionModel
     */
    lastlogin?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthSessionModel
     */
    lastused?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionModel
     */
    ipaddr?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionModel
     */
    devinfo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthSessionModel
     */
    iscurrent?: boolean;
}
/**
 * Breadcrumb
 * @export
 * @interface BreadcrumbModel
 */
export interface BreadcrumbModel {
    /**
     * 
     * @type {string}
     * @memberof BreadcrumbModel
     */
    folder_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BreadcrumbModel
     */
    title?: string;
}
/**
 * Document model
 * @export
 * @interface DocumentModel
 */
export interface DocumentModel {
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof DocumentModel
     */
    owner?: ProfileModel | string;
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof DocumentModel
     */
    updater?: ProfileModel | string;
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentModel
     */
    title?: string;
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentModel
     */
    body?: string;
    /**
     * Permission
     * @type {number}
     * @memberof DocumentModel
     */
    permission?: number;
    /**
     * document creation date
     * @type {number}
     * @memberof DocumentModel
     */
    created_at?: number;
    /**
     * document creation date
     * @type {number}
     * @memberof DocumentModel
     */
    updated_at?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentModel
     */
    uuid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentModel
     */
    editable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentModel
     */
    parentfolderid?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentModel
     */
    revision?: number;
}
/**
 * Document modify request model
 * @export
 * @interface DocumentModifyReqModel
 */
export interface DocumentModifyReqModel {
    /**
     * Owner UUID
     * @type {string}
     * @memberof DocumentModifyReqModel
     */
    owneruuid?: string;
    /**
     * Permission
     * @type {number}
     * @memberof DocumentModifyReqModel
     */
    permission?: number;
}
/**
 * Response of document creation
 * @export
 * @interface DocumentResModel
 */
export interface DocumentResModel {
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentResModel
     */
    doc_id: string;
}
/**
 * Folder list model
 * @export
 * @interface FolderListModel
 */
export interface FolderListModel {
    /**
     * 
     * @type {Array<FolderModel>}
     * @memberof FolderListModel
     */
    folder?: Array<FolderModel>;
    /**
     * 
     * @type {Array<DocumentModel>}
     * @memberof FolderListModel
     */
    document?: Array<DocumentModel>;
    /**
     * 
     * @type {Array<BreadcrumbModel>}
     * @memberof FolderListModel
     */
    path: Array<BreadcrumbModel>;
}
/**
 * Folder model
 * @export
 * @interface FolderModel
 */
export interface FolderModel {
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof FolderModel
     */
    owner?: ProfileModel | string;
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof FolderModel
     */
    updater?: ProfileModel | string;
    /**
     * Permission
     * @type {number}
     * @memberof FolderModel
     */
    permission?: number;
    /**
     * folder creation date
     * @type {number}
     * @memberof FolderModel
     */
    created_at?: number;
    /**
     * folder creation date
     * @type {number}
     * @memberof FolderModel
     */
    updated_at?: number;
    /**
     * 
     * @type {string}
     * @memberof FolderModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderModel
     */
    uuid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FolderModel
     */
    editable?: boolean;
}
/**
 * Folder modify request model
 * @export
 * @interface FolderModifyReqModel
 */
export interface FolderModifyReqModel {
    /**
     * Owner UUID
     * @type {string}
     * @memberof FolderModifyReqModel
     */
    owneruuid?: string;
    /**
     * Folder name
     * @type {string}
     * @memberof FolderModifyReqModel
     */
    name?: string;
    /**
     * Permission
     * @type {number}
     * @memberof FolderModifyReqModel
     */
    permission?: number;
}
/**
 * Member list
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    total?: number;
    /**
     * 
     * @type {Array<MemberInfoModel>}
     * @memberof InlineResponse200
     */
    members?: Array<MemberInfoModel>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    doc_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    folder_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    total?: number;
    /**
     * 
     * @type {Array<ProfileModel>}
     * @memberof InlineResponse2003
     */
    teams?: Array<ProfileModel>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    total?: number;
    /**
     * 
     * @type {Array<ProfileModel>}
     * @memberof InlineResponse2004
     */
    users?: Array<ProfileModel>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Image ID
     * @type {string}
     * @memberof InlineResponse2005
     */
    id?: string;
}
/**
 * JSON Web Token(JWT) is used for authorization. Geekers API uses only requred items.
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Issuer Claim.
     * @type {string}
     * @memberof JWT
     */
    iss?: string;
    /**
     * Subject Claim.
     * @type {string}
     * @memberof JWT
     */
    sub?: string;
    /**
     * Audience Claim. It keeps UUID.
     * @type {string}
     * @memberof JWT
     */
    aud: string;
    /**
     * Expiration Time Claim.
     * @type {number}
     * @memberof JWT
     */
    exp: number;
    /**
     * Not Before Claim.
     * @type {number}
     * @memberof JWT
     */
    nbf?: number;
    /**
     * Issued At Claim.
     * @type {number}
     * @memberof JWT
     */
    iat?: number;
    /**
     * JWT ID Claim. It keeps session ID.
     * @type {string}
     * @memberof JWT
     */
    jti: string;
}
/**
 * Member info model for /team/{teamid}/member
 * @export
 * @interface MemberInfoModel
 */
export interface MemberInfoModel {
    /**
     * Member profile or UUID
     * @type {ProfileModel | string}
     * @memberof MemberInfoModel
     */
    member?: ProfileModel | string;
    /**
     * Permission
     * @type {number}
     * @memberof MemberInfoModel
     */
    permission?: number;
}
/**
 * Profile model for get and post of /profile/{name}. Required items are attached in child items.
 * @export
 * @interface ProfileModel
 */
export interface ProfileModel {
    /**
     * UUID for user/team
     * @type {string}
     * @memberof ProfileModel
     */
    uuid: string;
    /**
     * Username or teamname
     * @type {string}
     * @memberof ProfileModel
     */
    name: string;
    /**
     * Biography
     * @type {string}
     * @memberof ProfileModel
     */
    bio?: string;
    /**
     * IconURI
     * @type {string}
     * @memberof ProfileModel
     */
    icon_uri: string;
    /**
     * User/team creation date
     * @type {number}
     * @memberof ProfileModel
     */
    created_at?: number;
    /**
     * Attribute(Official, SysAdmin)
     * @type {string}
     * @memberof ProfileModel
     */
    attr: string;
    /**
     * Team or not
     * @type {boolean}
     * @memberof ProfileModel
     */
    is_team: boolean;
    /**
     * List for joining teams
     * @type {Array<ProfileModel>}
     * @memberof ProfileModel
     */
    teams?: Array<ProfileModel>;
    /**
     * Language
     * @type {string}
     * @memberof ProfileModel
     */
    lang?: string;
    /**
     * Admin or not
     * @type {boolean}
     * @memberof ProfileModel
     */
    is_admin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileModel
     */
    is_lock?: boolean;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Unlock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthLock: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAuthLock', 'uuid', uuid)
            const localVarPath = `/auth/lock/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke session
         * @summary Revoke session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthSession: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAuthSession', 'id', id)
            const localVarPath = `/auth/session/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCheckUserUsername: async (token: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAuthCheckUserUsername', 'token', token)
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getAuthCheckUserUsername', 'userName', userName)
            const localVarPath = `/auth/check/user/{user_name}/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user lock status
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLock: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getAuthLock', 'uuid', uuid)
            const localVarPath = `/auth/lock/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log list
         * @summary Get logs
         * @param {string} [targetid] target team/userUUID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {string} [type] target log type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLog: async (targetid?: string, offset?: number, limit?: number, type?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (targetid !== undefined) {
                localVarQueryParameter['targetid'] = targetid;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthRegistPreToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAuthRegistPreToken', 'token', token)
            const localVarPath = `/auth/regist/pre/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session list
         * @summary Get session list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSession: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/check/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenRegist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/regist/gen/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassResetVerify: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPassResetVerify', 'token', token)
            const localVarPath = `/auth/pass/reset/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLock: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('postAuthLock', 'uuid', uuid)
            const localVarPath = `/auth/lock/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (authLoginReqModel?: AuthLoginReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassChange: async (authPassChangeReqModel?: AuthPassChangeReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/pass/change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authPassChangeReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassReset: async (authPassResetReqModel?: AuthPassResetReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/pass/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authPassResetReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassResetVerify: async (token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postPassResetVerify', 'token', token)
            const localVarPath = `/auth/pass/reset/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authPassChangeReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegist: async (token: string, authRegistReqModel?: AuthRegistReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postRegist', 'token', token)
            const localVarPath = `/auth/regist/pre/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegistReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegistVerify: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postRegistVerify', 'token', token)
            const localVarPath = `/auth/regist/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Unlock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthLock(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthLock(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Revoke session
         * @summary Revoke session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthSession(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthSession(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthCheckUserUsername(token: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthCheckUserUsername(token, userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Get user lock status
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthLock(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLockResModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthLock(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Get log list
         * @summary Get logs
         * @param {string} [targetid] target team/userUUID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {string} [type] target log type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthLog(targetid?: string, offset?: number, limit?: number, type?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogResModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthLog(targetid, offset, limit, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthRegistPreToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthRegistPreToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Get session list
         * @summary Get session list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthSession(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthSessionModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenRegist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegistNewTokenResModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewTokenRegist(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPassResetVerify(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPassResetVerify(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Lock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthLock(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLock(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginResModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogin(authLoginReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPassChange(authPassChangeReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPassReset(authPassResetReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPassResetVerify(token, authPassChangeReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegist(token, authRegistReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegistVerify(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRegistVerify(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Unlock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthLock(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAuthLock(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke session
         * @summary Revoke session
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthSession(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAuthSession(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCheckUserUsername(token: string, userName: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAuthCheckUserUsername(token, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user lock status
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLock(uuid: string, options?: any): AxiosPromise<AuthLockResModel> {
            return localVarFp.getAuthLock(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log list
         * @summary Get logs
         * @param {string} [targetid] target team/userUUID
         * @param {number} [offset] Offset
         * @param {number} [limit] Limit
         * @param {string} [type] target log type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLog(targetid?: string, offset?: number, limit?: number, type?: string, options?: any): AxiosPromise<AuthLogResModel> {
            return localVarFp.getAuthLog(targetid, offset, limit, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthRegistPreToken(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getAuthRegistPreToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session list
         * @summary Get session list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSession(options?: any): AxiosPromise<Array<AuthSessionModel>> {
            return localVarFp.getAuthSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckToken(options?: any): AxiosPromise<void> {
            return localVarFp.getCheckToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenRegist(options?: any): AxiosPromise<AuthRegistNewTokenResModel> {
            return localVarFp.getNewTokenRegist(options).then((request) => request(axios, basePath));
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassResetVerify(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getPassResetVerify(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock user
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLock(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.postAuthLock(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any): AxiosPromise<AuthLoginResModel> {
            return localVarFp.postLogin(authLoginReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout(options?: any): AxiosPromise<void> {
            return localVarFp.postLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.postPassChange(authPassChangeReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.postPassReset(authPassResetReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.postPassResetVerify(token, authPassChangeReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.postRegist(token, authRegistReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegistVerify(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.postRegistVerify(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Unlock user
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthLock(uuid: string, options?: any) {
        return AuthApiFp(this.configuration).deleteAuthLock(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke session
     * @summary Revoke session
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteAuthSession(id: string, options?: any) {
        return AuthApiFp(this.configuration).deleteAuthSession(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check username is not taken by other
     * @summary Check username
     * @param {string} token 
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthCheckUserUsername(token: string, userName: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthCheckUserUsername(token, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user lock status
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthLock(uuid: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthLock(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log list
     * @summary Get logs
     * @param {string} [targetid] target team/userUUID
     * @param {number} [offset] Offset
     * @param {number} [limit] Limit
     * @param {string} [type] target log type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthLog(targetid?: string, offset?: number, limit?: number, type?: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthLog(targetid, offset, limit, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to verify invitation link
     * @param {string} token Verification token for registration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthRegistPreToken(token: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthRegistPreToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session list
     * @summary Get session list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthSession(options?: any) {
        return AuthApiFp(this.configuration).getAuthSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks JWT token is valid.
     * @summary Check token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCheckToken(options?: any) {
        return AuthApiFp(this.configuration).getCheckToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to generate new key for registering new user.
     * @summary Generate new key for registering new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getNewTokenRegist(options?: any) {
        return AuthApiFp(this.configuration).getNewTokenRegist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check verification token to reset password. To change password with token, use POST methods.
     * @summary Check password reset token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getPassResetVerify(token: string, options?: any) {
        return AuthApiFp(this.configuration).getPassResetVerify(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock user
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthLock(uuid: string, options?: any) {
        return AuthApiFp(this.configuration).postAuthLock(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request login with email and password and returns JWT token.
     * @summary Login and get token
     * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any) {
        return AuthApiFp(this.configuration).postLogin(authLoginReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to logout. Server removes session key.
     * @summary Logout and remove session key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogout(options?: any) {
        return AuthApiFp(this.configuration).postLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to change password.
     * @summary Request to change password
     * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassChange(authPassChangeReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to reset password. Server sends verification email.
     * @summary Request to reset password
     * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassReset(authPassResetReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password with new one.
     * @summary Reset password
     * @param {string} token 
     * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassResetVerify(token, authPassChangeReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to register new user. Server sends verification email.
     * @summary Request to register new user
     * @param {string} token Verification token for registration.
     * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any) {
        return AuthApiFp(this.configuration).postRegist(token, authRegistReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify registration verification token. After verification, the account is added to user data and activated.
     * @summary Verify registration verification token
     * @param {string} token Verification token for registration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRegistVerify(token: string, options?: any) {
        return AuthApiFp(this.configuration).postRegistVerify(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDoc: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createNewDoc', 'folderId', folderId)
            const localVarPath = `/doc/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoc: async (docId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('deleteDoc', 'docId', docId)
            const localVarPath = `/doc/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocId: async (docId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getDocDocId', 'docId', docId)
            const localVarPath = `/doc/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocIdWs: async (docId: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('getDocDocIdWs', 'docId', docId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDocDocIdWs', 'token', token)
            const localVarPath = `/doc/{doc_id}/ws`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDoc: async (docId: string, folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('moveDoc', 'docId', docId)
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('moveDoc', 'folderId', folderId)
            const localVarPath = `/doc/{doc_id}/move/{folder_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocDocId: async (docId: string, documentModifyReqModel?: DocumentModifyReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('putDocDocId', 'docId', docId)
            const localVarPath = `/doc/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentModifyReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewDoc(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewDoc(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDoc(docId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDoc(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocDocId(docId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocDocId(docId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocDocIdWs(docId: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocDocIdWs(docId, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveDoc(docId: string, folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveDoc(docId, folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDocDocId(docId, documentModifyReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDoc(folderId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.createNewDoc(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoc(docId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDoc(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocId(docId: string, options?: any): AxiosPromise<DocumentModel> {
            return localVarFp.getDocDocId(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocIdWs(docId: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.getDocDocIdWs(docId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDoc(docId: string, folderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.moveDoc(docId, folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.putDocDocId(docId, documentModifyReqModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Just create new document and will return document id
     * @summary Make a new document
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createNewDoc(folderId: string, options?: any) {
        return DocumentApiFp(this.configuration).createNewDoc(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a document
     * @param {string} docId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDoc(docId: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDoc(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} docId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocDocId(docId: string, options?: any) {
        return DocumentApiFp(this.configuration).getDocDocId(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {string} docId 
     * @param {string} token security token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocDocIdWs(docId: string, token: string, options?: any) {
        return DocumentApiFp(this.configuration).getDocDocIdWs(docId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move document to target folder
     * @param {string} docId Folder ID
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public moveDoc(docId: string, folderId: string, options?: any) {
        return DocumentApiFp(this.configuration).moveDoc(docId, folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify document property
     * @param {string} docId Document ID
     * @param {DocumentModifyReqModel} [documentModifyReqModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any) {
        return DocumentApiFp(this.configuration).putDocDocId(docId, documentModifyReqModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFolder: async (folderId: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('createNewFolder', 'folderId', folderId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createNewFolder', 'name', name)
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('deleteFolder', 'folderId', folderId)
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (folderId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getList', 'folderId', folderId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getList', 'type', type)
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolder: async (folderId: string, folderModifyReqModel?: FolderModifyReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('modifyFolder', 'folderId', folderId)
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderModifyReqModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder: async (folderId: string, targetFolderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('moveFolder', 'folderId', folderId)
            // verify required parameter 'targetFolderId' is not null or undefined
            assertParamExists('moveFolder', 'targetFolderId', targetFolderId)
            const localVarPath = `/folder/{folder_id}/move/{target_folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"target_folder_id"}}`, encodeURIComponent(String(targetFolderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewFolder(folderId: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewFolder(folderId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(folderId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(folderId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyFolder(folderId, folderModifyReqModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFolder(folderId: string, targetFolderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFolder(folderId, targetFolderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * FolderApi - factory interface
 * @export
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderApiFp(configuration)
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFolder(folderId: string, name: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.createNewFolder(folderId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(folderId: string, type: string, options?: any): AxiosPromise<FolderListModel> {
            return localVarFp.getList(folderId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any): AxiosPromise<void> {
            return localVarFp.modifyFolder(folderId, folderModifyReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder(folderId: string, targetFolderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.moveFolder(folderId, targetFolderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
export class FolderApi extends BaseAPI {
    /**
     * 
     * @summary Make a new folder
     * @param {string} folderId Folder ID
     * @param {string} name Folder name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public createNewFolder(folderId: string, name: string, options?: any) {
        return FolderApiFp(this.configuration).createNewFolder(folderId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a folder
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public deleteFolder(folderId: string, options?: any) {
        return FolderApiFp(this.configuration).deleteFolder(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get document and folder list in the target folder
     * @param {string} folderId Folder ID
     * @param {string} type type that which list will be returned (all, folder, document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getList(folderId: string, type: string, options?: any) {
        return FolderApiFp(this.configuration).getList(folderId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify folder property
     * @param {string} folderId Folder ID
     * @param {FolderModifyReqModel} [folderModifyReqModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any) {
        return FolderApiFp(this.configuration).modifyFolder(folderId, folderModifyReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move folder to target parent.
     * @param {string} folderId Folder ID
     * @param {string} targetFolderId Target Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public moveFolder(folderId: string, targetFolderId: string, options?: any) {
        return FolderApiFp(this.configuration).moveFolder(folderId, targetFolderId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get uploaded image
         * @param {string} imgid Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageImgid: async (imgid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imgid' is not null or undefined
            assertParamExists('getImageImgid', 'imgid', imgid)
            const localVarPath = `/image/{imgid}`
                .replace(`{${"imgid"}}`, encodeURIComponent(String(imgid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload image
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImage: async (file: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postImage', 'file', file)
            const localVarPath = `/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get uploaded image
         * @param {string} imgid Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageImgid(imgid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageImgid(imgid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Upload image
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postImage(file: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get uploaded image
         * @param {string} imgid Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageImgid(imgid: string, options?: any): AxiosPromise<void> {
            return localVarFp.getImageImgid(imgid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload image
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postImage(file: any, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.postImage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @summary Get uploaded image
     * @param {string} imgid Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getImageImgid(imgid: string, options?: any) {
        return ImageApiFp(this.configuration).getImageImgid(imgid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload image
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postImage(file: any, options?: any) {
        return ImageApiFp(this.configuration).postImage(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} uuid Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileUuid: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getUserProfileUuid', 'uuid', uuid)
            const localVarPath = `/profile/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} uuid Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserProfileUuid: async (uuid: string, profileModel?: ProfileModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('putUserProfileUuid', 'uuid', uuid)
            const localVarPath = `/profile/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} uuid Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfileUuid(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfileUuid(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} uuid Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserProfileUuid(uuid: string, profileModel?: ProfileModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserProfileUuid(uuid, profileModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} uuid Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileUuid(uuid: string, options?: any): AxiosPromise<ProfileModel> {
            return localVarFp.getUserProfileUuid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} uuid Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserProfileUuid(uuid: string, profileModel?: ProfileModel, options?: any): AxiosPromise<void> {
            return localVarFp.putUserProfileUuid(uuid, profileModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Get profile for user/team.
     * @summary Get profile
     * @param {string} uuid Username or teamname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserProfileUuid(uuid: string, options?: any) {
        return ProfileApiFp(this.configuration).getUserProfileUuid(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit profile
     * @summary Edit profile
     * @param {string} uuid Username or teamname
     * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public putUserProfileUuid(uuid: string, profileModel?: ProfileModel, options?: any) {
        return ProfileApiFp(this.configuration).putUserProfileUuid(uuid, profileModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get team list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTeam: async (q?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {string} [filter] search condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUser: async (q?: string, limit?: number, offset?: number, filter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get team list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchTeam(q?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchTeam(q, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * 
         * @summary Get user list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {string} [filter] search condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchUser(q?: string, limit?: number, offset?: number, filter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchUser(q, limit, offset, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Get team list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchTeam(q?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getSearchTeam(q, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user list
         * @param {string} [q] search filter
         * @param {number} [limit] search limit
         * @param {number} [offset] search offset
         * @param {string} [filter] search condition filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUser(q?: string, limit?: number, offset?: number, filter?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getSearchUser(q, limit, offset, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Get team list
     * @param {string} [q] search filter
     * @param {number} [limit] search limit
     * @param {number} [offset] search offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearchTeam(q?: string, limit?: number, offset?: number, options?: any) {
        return SearchApiFp(this.configuration).getSearchTeam(q, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user list
     * @param {string} [q] search filter
     * @param {number} [limit] search limit
     * @param {number} [offset] search offset
     * @param {string} [filter] search condition filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearchUser(q?: string, limit?: number, offset?: number, filter?: string, options?: any) {
        return SearchApiFp(this.configuration).getSearchUser(q, limit, offset, filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamid: async (teamid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            assertParamExists('deleteTeamTeamid', 'teamid', teamid)
            const localVarPath = `/team/{teamid}`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamidMember: async (teamid: string, uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            assertParamExists('deleteTeamTeamidMember', 'teamid', teamid)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteTeamTeamidMember', 'uuid', uuid)
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {number} [limit] member limit
         * @param {number} [offset] member offset
         * @param {string} [uuid] uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamTeamidMember: async (teamid: string, limit?: number, offset?: number, uuid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            assertParamExists('getTeamTeamidMember', 'teamid', teamid)
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postTeam', 'name', name)
            const localVarPath = `/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamTeamidMember: async (teamid: string, memberInfoModel?: MemberInfoModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            assertParamExists('postTeamTeamidMember', 'teamid', teamid)
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberInfoModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTeamTeamidMember: async (teamid: string, memberInfoModel?: MemberInfoModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            assertParamExists('putTeamTeamidMember', 'teamid', teamid)
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memberInfoModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamTeamid(teamid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamTeamid(teamid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamTeamidMember(teamid: string, uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamTeamidMember(teamid, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {number} [limit] member limit
         * @param {number} [offset] member offset
         * @param {string} [uuid] uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamTeamidMember(teamid: string, limit?: number, offset?: number, uuid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamTeamidMember(teamid, limit, offset, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeam(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeam(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTeamTeamidMember(teamid, memberInfoModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putTeamTeamidMember(teamid, memberInfoModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, API_BASE_URL, configuration);
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamApiFp(configuration)
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamid(teamid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamTeamid(teamid, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamidMember(teamid: string, uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamTeamidMember(teamid, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {number} [limit] member limit
         * @param {number} [offset] member offset
         * @param {string} [uuid] uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamTeamidMember(teamid: string, limit?: number, offset?: number, uuid?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getTeamTeamidMember(teamid, limit, offset, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.postTeam(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): AxiosPromise<void> {
            return localVarFp.postTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): AxiosPromise<void> {
            return localVarFp.putTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Remove the team.
     * @summary Remove team
     * @param {string} teamid Team UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeamTeamid(teamid: string, options?: any) {
        return TeamApiFp(this.configuration).deleteTeamTeamid(teamid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the member from the team.
     * @summary Remove the member from the team
     * @param {string} teamid 
     * @param {string} uuid Removing member UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeamTeamidMember(teamid: string, uuid: string, options?: any) {
        return TeamApiFp(this.configuration).deleteTeamTeamidMember(teamid, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get team member list.
     * @summary Get team member list
     * @param {string} teamid 
     * @param {number} [limit] member limit
     * @param {number} [offset] member offset
     * @param {string} [uuid] uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamTeamidMember(teamid: string, limit?: number, offset?: number, uuid?: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamTeamidMember(teamid, limit, offset, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new team.
     * @summary Create team
     * @param {string} name Teamname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public postTeam(name: string, options?: any) {
        return TeamApiFp(this.configuration).postTeam(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add the member into the team.
     * @summary Add the member into team
     * @param {string} teamid 
     * @param {MemberInfoModel} [memberInfoModel] Member info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any) {
        return TeamApiFp(this.configuration).postTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify member info in the team.
     * @summary Modify member info in the team
     * @param {string} teamid 
     * @param {MemberInfoModel} [memberInfoModel] Member info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any) {
        return TeamApiFp(this.configuration).putTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(this.axios, this.basePath));
    }
}


