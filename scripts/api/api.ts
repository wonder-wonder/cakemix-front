// tslint:disable
/**
 * Cakemix Server API
 * Definition of Cakemix Server API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@wonder-wonder.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Request model for /auth/login
 * @export
 * @interface AuthLoginReqModel
 */
export interface AuthLoginReqModel {
    /**
     * Email address or username
     * @type {string}
     * @memberof AuthLoginReqModel
     */
    id: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthLoginReqModel
     */
    pass: string;
}
/**
 * Response model for /auth/login
 * @export
 * @interface AuthLoginResModel
 */
export interface AuthLoginResModel {
    /**
     * JWT token
     * @type {string}
     * @memberof AuthLoginResModel
     */
    jwt: string;
}
/**
 * Request model for /auth/pass/change and /auth/pass/reset/verify/{token}
 * @export
 * @interface AuthPassChangeReqModel
 */
export interface AuthPassChangeReqModel {
    /**
     * Old password
     * @type {string}
     * @memberof AuthPassChangeReqModel
     */
    oldpass?: string;
    /**
     * New password
     * @type {string}
     * @memberof AuthPassChangeReqModel
     */
    newpass: string;
}
/**
 * Request model for /auth/pass/reset
 * @export
 * @interface AuthPassResetReqModel
 */
export interface AuthPassResetReqModel {
    /**
     * Email for user to reset password
     * @type {string}
     * @memberof AuthPassResetReqModel
     */
    email: string;
}
/**
 * Request model for /auth/regist/new/token
 * @export
 * @interface AuthRegistNewTokenResModel
 */
export interface AuthRegistNewTokenResModel {
    /**
     * Token for registering
     * @type {string}
     * @memberof AuthRegistNewTokenResModel
     */
    token: string;
}
/**
 * Request model for /auth/regist
 * @export
 * @interface AuthRegistReqModel
 */
export interface AuthRegistReqModel {
    /**
     * Email address
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    email: string;
    /**
     * Username
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    username: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthRegistReqModel
     */
    password: string;
}
/**
 * Breadcrumb
 * @export
 * @interface BreadcrumbModel
 */
export interface BreadcrumbModel {
    /**
     * 
     * @type {string}
     * @memberof BreadcrumbModel
     */
    folderId?: string;
    /**
     * 
     * @type {string}
     * @memberof BreadcrumbModel
     */
    title?: string;
}
/**
 * Document model
 * @export
 * @interface DocumentModel
 */
export interface DocumentModel {
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof DocumentModel
     */
    owner?: ProfileModel | string;
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof DocumentModel
     */
    updater?: ProfileModel | string;
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentModel
     */
    title?: string;
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentModel
     */
    body?: string;
    /**
     * Permission
     * @type {number}
     * @memberof DocumentModel
     */
    permission?: number;
    /**
     * document creation date
     * @type {number}
     * @memberof DocumentModel
     */
    createdAt?: number;
    /**
     * document creation date
     * @type {number}
     * @memberof DocumentModel
     */
    updatedAt?: number;
}
/**
 * Document modify request model
 * @export
 * @interface DocumentModifyReqModel
 */
export interface DocumentModifyReqModel {
    /**
     * Owner UUID
     * @type {string}
     * @memberof DocumentModifyReqModel
     */
    owneruuid?: string;
    /**
     * Permission
     * @type {number}
     * @memberof DocumentModifyReqModel
     */
    permission?: number;
}
/**
 * Response of document creation
 * @export
 * @interface DocumentResModel
 */
export interface DocumentResModel {
    /**
     * Documentation
     * @type {string}
     * @memberof DocumentResModel
     */
    docId: string;
}
/**
 * Folder model
 * @export
 * @interface FolderModel
 */
export interface FolderModel {
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof FolderModel
     */
    owner?: ProfileModel | string;
    /**
     * 
     * @type {ProfileModel | string}
     * @memberof FolderModel
     */
    updater?: ProfileModel | string;
    /**
     * Permission
     * @type {number}
     * @memberof FolderModel
     */
    permission?: number;
    /**
     * folder creation date
     * @type {number}
     * @memberof FolderModel
     */
    createdAt?: number;
    /**
     * folder creation date
     * @type {number}
     * @memberof FolderModel
     */
    updatedAt?: number;
    /**
     * 
     * @type {Array<BreadcrumbModel>}
     * @memberof FolderModel
     */
    path?: Array<BreadcrumbModel>;
    /**
     * 
     * @type {string}
     * @memberof FolderModel
     */
    name?: string;
}
/**
 * Folder modify request model
 * @export
 * @interface FolderModifyReqModel
 */
export interface FolderModifyReqModel {
    /**
     * Owner UUID
     * @type {string}
     * @memberof FolderModifyReqModel
     */
    owneruuid?: string;
    /**
     * Folder name
     * @type {string}
     * @memberof FolderModifyReqModel
     */
    name?: string;
    /**
     * Permission
     * @type {number}
     * @memberof FolderModifyReqModel
     */
    permission?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    docId?: string;
}
/**
 * List of Folder and Document
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<FolderModel>}
     * @memberof InlineResponse2001
     */
    folder?: Array<FolderModel>;
    /**
     * 
     * @type {Array<DocumentModel>}
     * @memberof InlineResponse2001
     */
    document?: Array<DocumentModel>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    folderId?: string;
}
/**
 * JSON Web Token(JWT) is used for authorization. Geekers API uses only requred items.
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Issuer Claim.
     * @type {string}
     * @memberof JWT
     */
    iss?: string;
    /**
     * Subject Claim.
     * @type {string}
     * @memberof JWT
     */
    sub?: string;
    /**
     * Audience Claim. It keeps UUID.
     * @type {string}
     * @memberof JWT
     */
    aud: string;
    /**
     * Expiration Time Claim.
     * @type {number}
     * @memberof JWT
     */
    exp: number;
    /**
     * Not Before Claim.
     * @type {number}
     * @memberof JWT
     */
    nbf?: number;
    /**
     * Issued At Claim.
     * @type {number}
     * @memberof JWT
     */
    iat?: number;
    /**
     * JWT ID Claim. It keeps session ID.
     * @type {string}
     * @memberof JWT
     */
    jti: string;
}
/**
 * Member info model for /team/{teamid}/member
 * @export
 * @interface MemberInfoModel
 */
export interface MemberInfoModel {
    /**
     * Member profile or UUID
     * @type {ProfileModel | string}
     * @memberof MemberInfoModel
     */
    member?: ProfileModel | string;
    /**
     * Permission
     * @type {number}
     * @memberof MemberInfoModel
     */
    permission?: number;
}
/**
 * Profile model for get and post of /profile/{name}. Required items are attached in child items.
 * @export
 * @interface ProfileModel
 */
export interface ProfileModel {
    /**
     * UUID for user/team
     * @type {string}
     * @memberof ProfileModel
     */
    uuid: string;
    /**
     * Username or teamname
     * @type {string}
     * @memberof ProfileModel
     */
    name: string;
    /**
     * Biography
     * @type {string}
     * @memberof ProfileModel
     */
    bio?: string;
    /**
     * IconURI
     * @type {string}
     * @memberof ProfileModel
     */
    iconUri: string;
    /**
     * User/team creation date
     * @type {number}
     * @memberof ProfileModel
     */
    createdAt?: number;
    /**
     * Attribute(Official, SysAdmin)
     * @type {string}
     * @memberof ProfileModel
     */
    attr: string;
    /**
     * Team or not
     * @type {boolean}
     * @memberof ProfileModel
     */
    isTeam: boolean;
    /**
     * List for joining teams
     * @type {Array<ProfileModel>}
     * @memberof ProfileModel
     */
    teams?: Array<ProfileModel>;
    /**
     * Language
     * @type {string}
     * @memberof ProfileModel
     */
    lang?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCheckUserUsername: async (token: string, userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAuthCheckUserUsername.');
            }
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling getAuthCheckUserUsername.');
            }
            const localVarPath = `/auth/check/user/{user_name}/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthRegistPreToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAuthRegistPreToken.');
            }
            const localVarPath = `/auth/regist/pre/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/check/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenRegist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/regist/gen/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassResetVerify: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getPassResetVerify.');
            }
            const localVarPath = `/auth/pass/reset/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin: async (authLoginReqModel?: AuthLoginReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authLoginReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authLoginReqModel !== undefined ? authLoginReqModel : {}) : (authLoginReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassChange: async (authPassChangeReqModel?: AuthPassChangeReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/pass/change`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authPassChangeReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authPassChangeReqModel !== undefined ? authPassChangeReqModel : {}) : (authPassChangeReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassReset: async (authPassResetReqModel?: AuthPassResetReqModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/pass/reset`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authPassResetReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authPassResetReqModel !== undefined ? authPassResetReqModel : {}) : (authPassResetReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassResetVerify: async (token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postPassResetVerify.');
            }
            const localVarPath = `/auth/pass/reset/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authPassChangeReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authPassChangeReqModel !== undefined ? authPassChangeReqModel : {}) : (authPassChangeReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegist: async (token: string, authRegistReqModel?: AuthRegistReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postRegist.');
            }
            const localVarPath = `/auth/regist/pre/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authRegistReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authRegistReqModel !== undefined ? authRegistReqModel : {}) : (authRegistReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegistVerify: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postRegistVerify.');
            }
            const localVarPath = `/auth/regist/verify/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthCheckUserUsername(token: string, userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getAuthCheckUserUsername(token, userName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthRegistPreToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getAuthRegistPreToken(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getCheckToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewTokenRegist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegistNewTokenResModel>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getNewTokenRegist(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPassResetVerify(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).getPassResetVerify(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginResModel>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postLogin(authLoginReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLogout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postLogout(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postPassChange(authPassChangeReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postPassReset(authPassResetReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postPassResetVerify(token, authPassChangeReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postRegist(token, authRegistReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRegistVerify(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AuthApiAxiosParamCreator(configuration).postRegistVerify(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Check username is not taken by other
         * @summary Check username
         * @param {string} token 
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCheckUserUsername(token: string, userName: string, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).getAuthCheckUserUsername(token, userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to verify invitation link
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthRegistPreToken(token: string, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).getAuthRegistPreToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks JWT token is valid.
         * @summary Check token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckToken(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).getCheckToken(options).then((request) => request(axios, basePath));
        },
        /**
         * Request to generate new key for registering new user.
         * @summary Generate new key for registering new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewTokenRegist(options?: any): AxiosPromise<AuthRegistNewTokenResModel> {
            return AuthApiFp(configuration).getNewTokenRegist(options).then((request) => request(axios, basePath));
        },
        /**
         * Check verification token to reset password. To change password with token, use POST methods.
         * @summary Check password reset token
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassResetVerify(token: string, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).getPassResetVerify(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Request login with email and password and returns JWT token.
         * @summary Login and get token
         * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any): AxiosPromise<AuthLoginResModel> {
            return AuthApiFp(configuration).postLogin(authLoginReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to logout. Server removes session key.
         * @summary Logout and remove session key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogout(options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Request to change password.
         * @summary Request to change password
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postPassChange(authPassChangeReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to reset password. Server sends verification email.
         * @summary Request to reset password
         * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postPassReset(authPassResetReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password with new one.
         * @summary Reset password
         * @param {string} token 
         * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postPassResetVerify(token, authPassChangeReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to register new user. Server sends verification email.
         * @summary Request to register new user
         * @param {string} token Verification token for registration.
         * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postRegist(token, authRegistReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify registration verification token. After verification, the account is added to user data and activated.
         * @summary Verify registration verification token
         * @param {string} token Verification token for registration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRegistVerify(token: string, options?: any): AxiosPromise<void> {
            return AuthApiFp(configuration).postRegistVerify(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Check username is not taken by other
     * @summary Check username
     * @param {string} token 
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthCheckUserUsername(token: string, userName: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthCheckUserUsername(token, userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to verify invitation link
     * @param {string} token Verification token for registration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthRegistPreToken(token: string, options?: any) {
        return AuthApiFp(this.configuration).getAuthRegistPreToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks JWT token is valid.
     * @summary Check token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCheckToken(options?: any) {
        return AuthApiFp(this.configuration).getCheckToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to generate new key for registering new user.
     * @summary Generate new key for registering new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getNewTokenRegist(options?: any) {
        return AuthApiFp(this.configuration).getNewTokenRegist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check verification token to reset password. To change password with token, use POST methods.
     * @summary Check password reset token
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getPassResetVerify(token: string, options?: any) {
        return AuthApiFp(this.configuration).getPassResetVerify(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request login with email and password and returns JWT token.
     * @summary Login and get token
     * @param {AuthLoginReqModel} [authLoginReqModel] Login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogin(authLoginReqModel?: AuthLoginReqModel, options?: any) {
        return AuthApiFp(this.configuration).postLogin(authLoginReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to logout. Server removes session key.
     * @summary Logout and remove session key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogout(options?: any) {
        return AuthApiFp(this.configuration).postLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to change password.
     * @summary Request to change password
     * @param {AuthPassChangeReqModel} [authPassChangeReqModel] Old and new password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassChange(authPassChangeReqModel?: AuthPassChangeReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassChange(authPassChangeReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to reset password. Server sends verification email.
     * @summary Request to reset password
     * @param {AuthPassResetReqModel} [authPassResetReqModel] Email address to reset password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassReset(authPassResetReqModel?: AuthPassResetReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassReset(authPassResetReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password with new one.
     * @summary Reset password
     * @param {string} token 
     * @param {AuthPassChangeReqModel} [authPassChangeReqModel] New password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postPassResetVerify(token: string, authPassChangeReqModel?: AuthPassChangeReqModel, options?: any) {
        return AuthApiFp(this.configuration).postPassResetVerify(token, authPassChangeReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to register new user. Server sends verification email.
     * @summary Request to register new user
     * @param {string} token Verification token for registration.
     * @param {AuthRegistReqModel} [authRegistReqModel] Regist information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRegist(token: string, authRegistReqModel?: AuthRegistReqModel, options?: any) {
        return AuthApiFp(this.configuration).postRegist(token, authRegistReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify registration verification token. After verification, the account is added to user data and activated.
     * @summary Verify registration verification token
     * @param {string} token Verification token for registration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRegistVerify(token: string, options?: any) {
        return AuthApiFp(this.configuration).postRegistVerify(token, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocIdWs: async (docId: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling getDocDocIdWs.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDocDocIdWs.');
            }
            const localVarPath = `/doc/{doc_id}/ws`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocDocIdWs(docId: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getDocDocIdWs(docId, token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {string} docId 
         * @param {string} token security token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocDocIdWs(docId: string, token: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).getDocDocIdWs(docId, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Your GET endpoint
     * @param {string} docId 
     * @param {string} token security token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocDocIdWs(docId: string, token: string, options?: any) {
        return DefaultApiFp(this.configuration).getDocDocIdWs(docId, token, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDoc: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling createNewDoc.');
            }
            const localVarPath = `/doc/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoc: async (docId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling deleteDoc.');
            }
            const localVarPath = `/doc/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDoc: async (docId: string, folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling moveDoc.');
            }
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling moveDoc.');
            }
            const localVarPath = `/doc/{doc_id}/move/{folder_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocDocId: async (docId: string, documentModifyReqModel?: DocumentModifyReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling putDocDocId.');
            }
            const localVarPath = `/doc/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof documentModifyReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(documentModifyReqModel !== undefined ? documentModifyReqModel : {}) : (documentModifyReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewDoc(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).createNewDoc(folderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDoc(docId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).deleteDoc(docId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveDoc(docId: string, folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).moveDoc(docId, folderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DocumentApiAxiosParamCreator(configuration).putDocDocId(docId, documentModifyReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Just create new document and will return document id
         * @summary Make a new document
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDoc(folderId: string, options?: any): AxiosPromise<InlineResponse200> {
            return DocumentApiFp(configuration).createNewDoc(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a document
         * @param {string} docId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDoc(docId: string, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).deleteDoc(docId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move document to target folder
         * @param {string} docId Folder ID
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveDoc(docId: string, folderId: string, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).moveDoc(docId, folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify document property
         * @param {string} docId Document ID
         * @param {DocumentModifyReqModel} [documentModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any): AxiosPromise<void> {
            return DocumentApiFp(configuration).putDocDocId(docId, documentModifyReqModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Just create new document and will return document id
     * @summary Make a new document
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createNewDoc(folderId: string, options?: any) {
        return DocumentApiFp(this.configuration).createNewDoc(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a document
     * @param {string} docId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDoc(docId: string, options?: any) {
        return DocumentApiFp(this.configuration).deleteDoc(docId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move document to target folder
     * @param {string} docId Folder ID
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public moveDoc(docId: string, folderId: string, options?: any) {
        return DocumentApiFp(this.configuration).moveDoc(docId, folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify document property
     * @param {string} docId Document ID
     * @param {DocumentModifyReqModel} [documentModifyReqModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public putDocDocId(docId: string, documentModifyReqModel?: DocumentModifyReqModel, options?: any) {
        return DocumentApiFp(this.configuration).putDocDocId(docId, documentModifyReqModel, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FolderApi - axios parameter creator
 * @export
 */
export const FolderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFolder: async (folderId: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling createNewFolder.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createNewFolder.');
            }
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling deleteFolder.');
            }
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (folderId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling getList.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getList.');
            }
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolder: async (folderId: string, folderModifyReqModel?: FolderModifyReqModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling modifyFolder.');
            }
            const localVarPath = `/folder/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof folderModifyReqModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(folderModifyReqModel !== undefined ? folderModifyReqModel : {}) : (folderModifyReqModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder: async (folderId: string, targetFolderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            if (folderId === null || folderId === undefined) {
                throw new RequiredError('folderId','Required parameter folderId was null or undefined when calling moveFolder.');
            }
            // verify required parameter 'targetFolderId' is not null or undefined
            if (targetFolderId === null || targetFolderId === undefined) {
                throw new RequiredError('targetFolderId','Required parameter targetFolderId was null or undefined when calling moveFolder.');
            }
            const localVarPath = `/folder/{folder_id}/move/{target_folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)))
                .replace(`{${"target_folder_id"}}`, encodeURIComponent(String(targetFolderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderApi - functional programming interface
 * @export
 */
export const FolderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewFolder(folderId: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await FolderApiAxiosParamCreator(configuration).createNewFolder(folderId, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FolderApiAxiosParamCreator(configuration).deleteFolder(folderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(folderId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await FolderApiAxiosParamCreator(configuration).getList(folderId, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FolderApiAxiosParamCreator(configuration).modifyFolder(folderId, folderModifyReqModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFolder(folderId: string, targetFolderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FolderApiAxiosParamCreator(configuration).moveFolder(folderId, targetFolderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FolderApi - factory interface
 * @export
 */
export const FolderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Make a new folder
         * @param {string} folderId Folder ID
         * @param {string} name Folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewFolder(folderId: string, name: string, options?: any): AxiosPromise<InlineResponse2002> {
            return FolderApiFp(configuration).createNewFolder(folderId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a folder
         * @param {string} folderId Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderId: string, options?: any): AxiosPromise<void> {
            return FolderApiFp(configuration).deleteFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get document and folder list in the target folder
         * @param {string} folderId Folder ID
         * @param {string} type type that which list will be returned (all, folder, document)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(folderId: string, type: string, options?: any): AxiosPromise<InlineResponse2001> {
            return FolderApiFp(configuration).getList(folderId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify folder property
         * @param {string} folderId Folder ID
         * @param {FolderModifyReqModel} [folderModifyReqModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any): AxiosPromise<void> {
            return FolderApiFp(configuration).modifyFolder(folderId, folderModifyReqModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move folder to target parent.
         * @param {string} folderId Folder ID
         * @param {string} targetFolderId Target Folder ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder(folderId: string, targetFolderId: string, options?: any): AxiosPromise<void> {
            return FolderApiFp(configuration).moveFolder(folderId, targetFolderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderApi - object-oriented interface
 * @export
 * @class FolderApi
 * @extends {BaseAPI}
 */
export class FolderApi extends BaseAPI {
    /**
     * 
     * @summary Make a new folder
     * @param {string} folderId Folder ID
     * @param {string} name Folder name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public createNewFolder(folderId: string, name: string, options?: any) {
        return FolderApiFp(this.configuration).createNewFolder(folderId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a folder
     * @param {string} folderId Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public deleteFolder(folderId: string, options?: any) {
        return FolderApiFp(this.configuration).deleteFolder(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get document and folder list in the target folder
     * @param {string} folderId Folder ID
     * @param {string} type type that which list will be returned (all, folder, document)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public getList(folderId: string, type: string, options?: any) {
        return FolderApiFp(this.configuration).getList(folderId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify folder property
     * @param {string} folderId Folder ID
     * @param {FolderModifyReqModel} [folderModifyReqModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public modifyFolder(folderId: string, folderModifyReqModel?: FolderModifyReqModel, options?: any) {
        return FolderApiFp(this.configuration).modifyFolder(folderId, folderModifyReqModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move folder to target parent.
     * @param {string} folderId Folder ID
     * @param {string} targetFolderId Target Folder ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderApi
     */
    public moveFolder(folderId: string, targetFolderId: string, options?: any) {
        return FolderApiFp(this.configuration).moveFolder(folderId, targetFolderId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} userName Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileUuid: async (userName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling getUserProfileUuid.');
            }
            const localVarPath = `/profile/{user_name}`
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} userName Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserProfileUuid: async (userName: string, profileModel?: ProfileModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName','Required parameter userName was null or undefined when calling putUserProfileUuid.');
            }
            const localVarPath = `/profile/{user_name}`
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof profileModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(profileModel !== undefined ? profileModel : {}) : (profileModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} userName Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfileUuid(userName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileModel>> {
            const localVarAxiosArgs = await ProfileApiAxiosParamCreator(configuration).getUserProfileUuid(userName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} userName Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserProfileUuid(userName: string, profileModel?: ProfileModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProfileApiAxiosParamCreator(configuration).putUserProfileUuid(userName, profileModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get profile for user/team.
         * @summary Get profile
         * @param {string} userName Username or teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfileUuid(userName: string, options?: any): AxiosPromise<ProfileModel> {
            return ProfileApiFp(configuration).getUserProfileUuid(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit profile
         * @summary Edit profile
         * @param {string} userName Username or teamname
         * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserProfileUuid(userName: string, profileModel?: ProfileModel, options?: any): AxiosPromise<void> {
            return ProfileApiFp(configuration).putUserProfileUuid(userName, profileModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Get profile for user/team.
     * @summary Get profile
     * @param {string} userName Username or teamname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUserProfileUuid(userName: string, options?: any) {
        return ProfileApiFp(this.configuration).getUserProfileUuid(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit profile
     * @summary Edit profile
     * @param {string} userName Username or teamname
     * @param {ProfileModel} [profileModel] Updated profile data. The parameters can be omitted if no update. Some parameter cannot be changed because of readonly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public putUserProfileUuid(userName: string, profileModel?: ProfileModel, options?: any) {
        return ProfileApiFp(this.configuration).putUserProfileUuid(userName, profileModel, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamid: async (teamid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            if (teamid === null || teamid === undefined) {
                throw new RequiredError('teamid','Required parameter teamid was null or undefined when calling deleteTeamTeamid.');
            }
            const localVarPath = `/team/{teamid}`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamidMember: async (teamid: string, uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            if (teamid === null || teamid === undefined) {
                throw new RequiredError('teamid','Required parameter teamid was null or undefined when calling deleteTeamTeamidMember.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteTeamTeamidMember.');
            }
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamTeamidMember: async (teamid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            if (teamid === null || teamid === undefined) {
                throw new RequiredError('teamid','Required parameter teamid was null or undefined when calling getTeamTeamidMember.');
            }
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postTeam.');
            }
            const localVarPath = `/team`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamTeamidMember: async (teamid: string, memberInfoModel?: MemberInfoModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            if (teamid === null || teamid === undefined) {
                throw new RequiredError('teamid','Required parameter teamid was null or undefined when calling postTeamTeamidMember.');
            }
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof memberInfoModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(memberInfoModel !== undefined ? memberInfoModel : {}) : (memberInfoModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTeamTeamidMember: async (teamid: string, memberInfoModel?: MemberInfoModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamid' is not null or undefined
            if (teamid === null || teamid === undefined) {
                throw new RequiredError('teamid','Required parameter teamid was null or undefined when calling putTeamTeamidMember.');
            }
            const localVarPath = `/team/{teamid}/member`
                .replace(`{${"teamid"}}`, encodeURIComponent(String(teamid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof memberInfoModel !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(memberInfoModel !== undefined ? memberInfoModel : {}) : (memberInfoModel || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamTeamid(teamid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).deleteTeamTeamid(teamid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamTeamidMember(teamid: string, uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).deleteTeamTeamidMember(teamid, uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamTeamidMember(teamid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberInfoModel>>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).getTeamTeamidMember(teamid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeam(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).postTeam(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).postTeamTeamidMember(teamid, memberInfoModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamApiAxiosParamCreator(configuration).putTeamTeamidMember(teamid, memberInfoModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove the team.
         * @summary Remove team
         * @param {string} teamid Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamid(teamid: string, options?: any): AxiosPromise<void> {
            return TeamApiFp(configuration).deleteTeamTeamid(teamid, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the member from the team.
         * @summary Remove the member from the team
         * @param {string} teamid 
         * @param {string} uuid Removing member UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamTeamidMember(teamid: string, uuid: string, options?: any): AxiosPromise<void> {
            return TeamApiFp(configuration).deleteTeamTeamidMember(teamid, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get team member list.
         * @summary Get team member list
         * @param {string} teamid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamTeamidMember(teamid: string, options?: any): AxiosPromise<Array<MemberInfoModel>> {
            return TeamApiFp(configuration).getTeamTeamidMember(teamid, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new team.
         * @summary Create team
         * @param {string} name Teamname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeam(name: string, options?: any): AxiosPromise<void> {
            return TeamApiFp(configuration).postTeam(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add the member into the team.
         * @summary Add the member into team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): AxiosPromise<void> {
            return TeamApiFp(configuration).postTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify member info in the team.
         * @summary Modify member info in the team
         * @param {string} teamid 
         * @param {MemberInfoModel} [memberInfoModel] Member info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any): AxiosPromise<void> {
            return TeamApiFp(configuration).putTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Remove the team.
     * @summary Remove team
     * @param {string} teamid Team UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeamTeamid(teamid: string, options?: any) {
        return TeamApiFp(this.configuration).deleteTeamTeamid(teamid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the member from the team.
     * @summary Remove the member from the team
     * @param {string} teamid 
     * @param {string} uuid Removing member UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeamTeamidMember(teamid: string, uuid: string, options?: any) {
        return TeamApiFp(this.configuration).deleteTeamTeamidMember(teamid, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get team member list.
     * @summary Get team member list
     * @param {string} teamid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeamTeamidMember(teamid: string, options?: any) {
        return TeamApiFp(this.configuration).getTeamTeamidMember(teamid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new team.
     * @summary Create team
     * @param {string} name Teamname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public postTeam(name: string, options?: any) {
        return TeamApiFp(this.configuration).postTeam(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add the member into the team.
     * @summary Add the member into team
     * @param {string} teamid 
     * @param {MemberInfoModel} [memberInfoModel] Member info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public postTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any) {
        return TeamApiFp(this.configuration).postTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify member info in the team.
     * @summary Modify member info in the team
     * @param {string} teamid 
     * @param {MemberInfoModel} [memberInfoModel] Member info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public putTeamTeamidMember(teamid: string, memberInfoModel?: MemberInfoModel, options?: any) {
        return TeamApiFp(this.configuration).putTeamTeamidMember(teamid, memberInfoModel, options).then((request) => request(this.axios, this.basePath));
    }

}


